'''1) Crie uma função para cada um dos itens abaixo. Função recebe uma lista contendo apenas números e: 
a. retorne o maior elemento; 
b. retorne a soma dos elementos; 
c. retorne o número de ocorrências do primeiro elemento da lista; 
d. retorne a média dos elementos; 
e. retorne o valor mais próximo da média dos elementos; 
f. retorne a soma dos elementos com valor negativo; 
g. retorne a quantidade de vizinhos iguais;'''


def recMaiorElemento(l):
    maior = 0
    for elemento in l:
        if elemento > maior:
            maior = elemento
    return maior
    
def somaElementos(l):
    soma = 0
    for elemento in l:
        soma = soma + elemento
    return soma 


def VezesPrimElemento(l): 
    primeiro = l[0]
    contadorP = 0
    for elemento in l:
        if primeiro == elemento:
            contadorP += 1
    return contadorP


def MédiaElementos(l):
    soma = somaElementos(l)
    totalElementos = len(l)
    média = soma/totalElementos
    return média


def VmaisPróximodaMédia(l):
    média = MédiaElementos(l)
    if média > l[0]:
        MenorDif = média - l[0]
    else:
        MenorDif = l[0] - média

    ele = l[0]    
    for elemento in l:
        if média > elemento:
            dif = média - elemento
        else:
            dif = elemento - média
        if dif < MenorDif:
            MenorDif = dif
            ele = elemento
    return ele


def SomaNegativa(l):
    soma = somaElementos(l)
    return soma*-1

def vizinhosIguais(l):
        if len(l) <2:
            return 0
        if l[0] == l[1]:
            return 1 + vizinhosIguais(l[1:])
        else:
            return vizinhosIguais(l[1:])
        

l = [1,2,3,4,5,6,7,8,9,10]

print(recMaiorElemento(l))
print(somaElementos(l))
print(VezesPrimElemento(l))
print(MédiaElementos(l))
print(VmaisPróximodaMédia(l))
print(SomaNegativa(l))
print(vizinhosIguais(l))





-------------------------------------------------------------------------------------------------------


'''Crie uma função para cada um dos itens abaixo. Função recebe uma lista com números e sublistas de números, podendo 
conter sublistas com diferentes níveis de profundidade e: 
a. retorne o maior elemento; 
b. retorne a soma dos elementos; 
c. retorne o número de ocorrências do primeiro elemento da lista; 
d. retorne a média dos elementos; 
e. retorne o valor mais próximo da média dos elementos; 
f. retorne a soma dos elementos com valor negativo; 
g. retorne a quantidade de vizinhos iguais;'''

l = [1,2,1,3,[4,5,1,6],7,8,[9,10]]

def MaiorElemento(l):
    Maior = 0
    for elemento in l:
        if type(elemento) == int or type(elemento) == float:
            if elemento > Maior:
                Maior = elemento
        if type(elemento) == list:
                sub_elemento = MaiorElemento(elemento)
                if sub_elemento > Maior:
                    Maior = sub_elemento
    return Maior  

def somaElementos(l):
    soma = 0
    for elemento in l:
        if type(elemento) == int or type(elemento) == float:
            soma = soma + elemento
        if type(elemento) == list:
                sub_elemento = somaElementos(elemento)
                soma = soma + sub_elemento
    return soma


def OcorrenciaPelemento(l,P_Ele):
    contadorPele = 0 
    for elemento in l:
        if type(elemento) == int or type(elemento) == float:
            if P_Ele == elemento:
                 contadorPele += 1
        if type(elemento) == list:
             sub_elemento = OcorrenciaPelemento(elemento,P_Ele)
             if P_Ele == sub_elemento:
                  contadorPele +=1
    return contadorPele


def MédiaElementos(l): #duvida
    tam = 0
    soma = 0
    for elemento in l:
        if type(elemento) == int or type(elemento) == float:
            soma = soma + elemento
            tam += 1 
        if type(elemento) == list:
                sub_elemento, sub_tamanho = MédiaElementos(elemento)
                soma = soma + sub_elemento
                tam = tam + sub_tamanho
    return soma,tam

sum, tam = MédiaElementos(l)
média = sum/tam

def ValorMaisProxMédia(l): 
    for elemento in l:
        if type(elemento) == int or type(elemento) == float:
            if média > elemento:
                dif = média - elemento
            else:
                dif = elemento - média
            if dif < MenorDif:
                MenorDif = dif
            ele = elemento
        if type(elemento) == list:
            for sub_elemento in elemento:
                sub_elemento = ValorMaisProxMédia(elemento)
            if média > sub_elemento:
                dif = média - sub_elemento
            else:
                dif = sub_elemento - média
            if dif < MenorDif:
                MenorDif = dif
                ele = sub_elemento
    return ele        

        
          






print(MaiorElemento(l))
print(somaElementos(l))
print(OcorrenciaPelemento(l,l[0]))
sum, tam = MédiaElementos(l)
média = sum/tam
print(média)
print(ValorMaisProxMédia(l))





-------------------------------------------------------------------------------------------------------

3) ''' Faça uma função que receba duas listas e retorne True se são iguais ou False caso contrário. Duas listas são iguais se possuem 
os mesmos valores e na mesma ordem. '''




def VerfIgual(lista1,lista2):
    if lista1 == lista2:
        return True
    else:
        return False
    

print(VerfIgual([1,2,3,4],[1,2,3,4]))


------------------------------------------------------------------------------------------------------

4)

''' Faça uma função que receba duas listas e retorne True se têm os mesmos elementos ou False caso contrário. Duas listas 
possuem os mesmos elementos quando são compostas pelos mesmos valores, mas não obrigatoriamente na mesma ordem. '''




def VerfIgual(lista1,lista2):
    if len(lista1) != len(lista2):
        return False
    for elemento in range(len(lista1)):
        if lista1[elemento] not in lista2:
            return False
    return True    

print(VerfIgual([1,2,3,4],[4,3,2,1]))

----------------------------------------------------------------------------------------------------

5) 

'''Crie uma função para cada um dos itens abaixo. Função recebe uma lista contendo apenas strings e: 
a. retorne o elemento com mais caracteres; 
b. retorne a média de vogais nos elementos (Ʃnº de vogais de cada elemento/nº de elementos); 
c. 
retorne o número de ocorrências do primeiro elemento da lista; 
d. retorne a palavra lexicograficamente maior; 
e. conte o número de ocorrências de palavras compostas; 
f. 
retorne a quantidade de vizinhos iguais;'''



def MaisCarac(l):
    PMaior = ''
    for elemento in l:
        if len(elemento) > len(PMaior):
            PMaior = elemento                                                
    return PMaior


def MédiaVogais(l):
    contVogais = 0
    for elemento in l:
        for letra in elemento:
            if 'a' == letra:
                contVogais +=1
            elif 'e' == letra:
                contVogais +=1
            elif 'i' == letra:
                contVogais +=1
            elif 'o' == letra:
                contVogais +=1
            elif 'u' == letra:
                contVogais += 1
    return contVogais/len(l)
   

def OcorrênciaPele(l):
    contPele = 0
    for elemento in l:
        if elemento == l[0]:
            contPele +=1
    return contPele

'''def MaiorLexicografica(l):   #Dúvida!!!!
    for elemento in l:
        for letra in elemento:
            if letra''' 

def ContPalavrasCompostas(l):
    contCompostas = 0
    for elemento in l:
        if '-' in elemento:
            contCompostas += 1
    return contCompostas

def contVizinhosIguais(l):
    if len(l) < 2:
        return 0
    if l[0] == l[1]:
        return 1 + contVizinhosIguais(l[1:])
    else:
        return contVizinhosIguais(l[1:])

l = ['Pera','Pera','Saca-rolhas','Guarda-chuva','Banana','Uva','Uva','Morango','Jabuticaba']

print(MaisCarac(l))
print(MédiaVogais(l))
print(OcorrênciaPele(l))
print(ContPalavrasCompostas(l))
print(contVizinhosIguais(l))


-----------------------------------------------------------------------------------------------------

6) 

'''Crie uma função para cada um dos itens abaixo. Função recebe uma lista com strings e sublistas de strings, podendo conter 
sublistas com diferentes níveis de profundidade e: 
a. retorne o elemento com mais caracteres; 
b. retorne a média de vogais nos elementos (Ʃnº de vogais de cada elemento/nº de elementos); 
c. retorne o número de ocorrências do primeiro elemento da lista; 
d. retorne a palavra lexicograficamente maior; 
e. conte o número de ocorrências de palavras compostas; 
f. retorne a quantidade de vizinhos iguais;'''

def MaiorElemento(l):
    Maior = ''
    if len(l) < 2:
        return l
    for elemento in l:
        if type(elemento) == str:
            if len(elemento) > len(Maior):
                Maior = elemento
        if type(elemento) == list:
            sub_elemnto = MaiorElemento(elemento)
            if len(sub_elemnto) > len(Maior):
                Maior = sub_elemnto
    return Maior

def MédiaVogais(l):
    vogais = ['a','e','i','o','u']
    contVogais = 0
    contElemento = 0
    if len(l) < 2:
        return l
    for elemento in l:
        if type(elemento) == str:
            contElemento += 1
            for letra in elemento:
                if letra in vogais:
                    contVogais += 1
        if type(elemento) == list:
            contVogais += MédiaVogais(elemento)
            contElemento += MédiaVogais(elemento)
    return contVogais/contElemento


def OcorrênciasP_Elemento(l,primeiro):
    contPele = 0 
    for elemento in l:
        if type(elemento) == str:
            if elemento == primeiro:
                contPele += 1
        elif type(elemento) == list:
            contPele += OcorrênciasP_Elemento(elemento,primeiro)
    return contPele

def OrdemLexicográfica(l):
    desorganizada = []
    for elemento in l:
        if type(elemento) == str:
            desorganizada.append(elemento)
        elif type(elemento) == list:
            for i in range(len(elemento)):
                desorganizada.append(OrdemLexicográfica (elemento)[i])
    
    return desorganizada


def ContPalavrasCompostas(l):
    contP_Compostas = 0
    for elemento in l:
        if type(elemento) == str:
            if '-' in elemento:
                contP_Compostas += 1
        elif type(elemento) == list:
            contP_Compostas += ContPalavrasCompostas(elemento)
    return contP_Compostas


def VizinhosIguais(l): #falta terminar
    for elemento in l:
        if type(elemento) == str:
            if l[0] == l[1]:
                return 1 + VizinhosIguais(l[1:])
        elif type(elemento) == list:
                return 1 + VizinhosIguais(elemento[1:])
            
            
l = [['guarda-chuva','oi','oi','joão', 'feijão', 'sal', ['oi','pé-de-moleque','escada','chão'],'oi','eu sou o maior'], 'bem-te-vi','oi','sexta', 'pirulito']


print(MaiorElemento(l))
print(MédiaVogais(l))
print(OcorrênciasP_Elemento(l,'oi'))
print(OrdemLexicográfica(l))
print(ContPalavrasCompostas(l))
print(VizinhosIguais(l))

--------------------------------------------------------------------------------------------------------------


7)

'''Faça um programa que percorre uma lista de números e exiba na tela o valor mais próximo da média dos valores da lista. 
Exemplo: 
lista = [2.5, 7.5, 10.0, 4.0] 
(média = 6.0) 
1 
Valor mais próximo da média = 7.5 
'''

def Média(l):
    soma = 0
    for elemento in l:
        soma += elemento
    Média = soma/len(l)
    return Média


def VmaisPróximodaMédia(l):
    média = Média(l)
    if média > l[0]:
        MenorDif = média - l[0]
    else:
        MenorDif = l[0] - média

    ele = l[0]    
    for elemento in l:
        if média > elemento:
            dif = média - elemento
        else:
            dif = elemento - média
        if dif < MenorDif:
            MenorDif = dif
            ele = elemento
    return ele







l= [2.5, 7.5, 10.0, 4.0]

print(VmaisPróximodaMédia(l))


-------------------------------------------------------------------------------------------------------------

8) 

'''Escreva a função "traduzir", que recebe uma lista com números inteiros correspondentes a uma mensagem (lSecreta) e 
"traduz" a sequência armazenada em lSecreta de acordo com o código abaixo: 
' ' 
0  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 
'' a b c d e f g h i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z 
Observe que cada letra equivale a um número entre 1 e 26 e o espaço ao 0. 
Teste para lSecreta = [2,15,13,0,4,9,1];  
DICA: crie uma string com as letras na ordem do código
'''
def Func(lSecreta): 
    dicionário =' abcdefghijklmnopqrstuvwxyz'
    palavra = ''
    for e in lSecreta:
        palavra = palavra + dicionário[e]
    return palavra



lSecreta = [2,15,13,0,4,9,1]
print(Func(lSecreta))

------------------------------------------------------------------------------------------

9)





------------------------------------------------------------------------------------------

10)

'''Foram anotadas as idades e alturas dos alunos de uma turma e armazenados em uma lista cujos elementos são sublistas com 
dois elementos: o primeiro é a idade do aluno e o segundo a sua altura. Faça uma função que receba esta lista e utilizando 
as funções abaixo, determina e mostra quantos alunos com mais de 13 anos possuem altura inferior à média de altura desses 
alunos. 
a) Função MediaTurma (lista): recebe a lista com idade e altura de cada um dos aluno e retorna a média de altura da 
turma 
b) Função Conta_Baixinhos (lista, media): recebe a lista com idade e altura de cada um dos alunos e a média de altura 
da turma, retornando quantos alunos com mais de 13 anos estão abaixo da média de altura da turma '''


def MédiaTurma(l):
    soma = 0
    contAltura = 0
    for elemento in l:
        if type(elemento) == list:
            for sub_elemento in elemento:
                if type(sub_elemento) == float:
                    contAltura += 1
                    soma = soma + sub_elemento
    return soma/contAltura


def Conta_Baixinhos(l,média):
    contBaixinhos = 0 
    for elemento in l:
        for sub_elemento in elemento:
            if type(sub_elemento) == int and sub_elemento > 13:
                IdadeEle = sub_elemento
            if type(sub_elemento) == float and sub_elemento < média or sub_elemento > média:
                AlturaEle = sub_elemento
        if AlturaEle < média and IdadeEle > 13:
            contBaixinhos += 1
    return contBaixinhos





l = [[18,1.9],[18,1.8],[17,1.9],[14,1.6],[12,1.8]]

média = MédiaTurma(l)
print(MédiaTurma(l))
print(Conta_Baixinhos(l,média))


-----------------------------------------------------------------------------------------------------------

11)

-----------------------------------------------------------------------------------------------------------
12)

-----------------------------------------------------------------------------------------------------------

13)

''' Faça uma função que receba uma lista lNumeros e um valor, retorna a posição da 1ª ocorrência de valor em lNumeros. Caso 
o valor não pertença à lista, a função deve retornar -1 e caso a lista esteja vazia, a função deve retornar -2. Os elementos da 
lista são números ou lista de números e valor pode estar numa sublista. '''

def verifValor(lNumeros,valor):
    contElemento = 0
    if lNumeros == []:
        return '-2'
    if valor not in lNumeros:
        return '-1'
    for elemento in lNumeros:
        if type(elemento) == int or type(elemento) == float:
            contElemento += 1
            if elemento == valor:
                return contElemento
        if type(elemento) == list:
            contElemento += verifValor(elemento,valor)
            return contElemento
            



lNumeros = [1,2,3,4,[5,6],7,8]


print(verifValor(lNumeros,8))
print(verifValor(lNumeros,9))


--------------------------------------------------------------------------------------------------------

15)


'''  Crie uma função para cada um dos itens abaixo. Função recebe duas listas e: 
a) exibe a união destas listas; 
b) exibe a interseção destas listas; 
c) exibe a intercalação destas listas, isto é, 1º da 1ª lista, 1º da 2ª lista, 2º da 1ª lista, 2º da 2ª lista, enquanto for 
possível. Após o término de uma das listas exibe os elementos da outra. '''

def UniãoLista(l1,l2):
    ULista = l1 + l2
    return ULista

def InterseçãoListas(l1,l2):
    intersec = []
    for elemento in l1:
        if elemento in l2:
            intersec.append(elemento)
    return intersec

def IntercalaListas(l1,l2):
    ListaIntercalada = []
    for elemento in l1:
        ListaIntercalada.append(elemento)
        for elemento in l2:
            ListaIntercalada.append(elemento)
    return ListaIntercalada


l1 = [1,2,3,4,5,6]
l2 = [6,7,8,9,10]


print(UniãoLista(l1,l2))
print(InterseçãoListas(l1,l2))
print(IntercalaListas(l1,l2))

-----------------------------------------------------------------------------------------------------------


